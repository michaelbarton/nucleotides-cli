"""\
Module for interacting with the filesystem relative to the current nucleotides task
directory. Each nucleotides benchmarking task takes place in a directory named for
the nucleotides task ID. This module functions to simplify getting the location of
where input files can be found, and where output files should be created.
"""
import os.path, json, funcy, sys

import ruamel.yaml        as yaml
import boltons.fileutils  as fu
import nucleotides.util   as util

#########################################
#
# Files and directories with the nucleotides task
#
#########################################

def get_task_dir_path(app, location):
    """
    Return the path to the given sub directory within the nucleotides task
    directory. Creates the directory if it does not already exist.
    """
    dir_path = os.path.join(app['path'], location)
    fu.mkdir_p(dir_path)
    return os.path.join(app['path'], location)


def get_task_file_path(app, location):
    """
    Return the path to the given file within the given nucleotides task directory.
    Creates the parent directory if it does not already exist.
    """
    dir_path = os.path.dirname(os.path.join(app['path'], location))
    fu.mkdir_p(dir_path)
    return os.path.join(app['path'], location)


def get_task_path_file_without_name(app, name):
    """
    Return the path for the first file listed within the given nucleotides task
    directory. Used to get file paths from directories when the file name is not
    known.
    """
    path  = get_task_dir_path(app, name)
    files = os.listdir(path)
    if len(files) == 1:
        return os.path.join(path, files[0])
    elif len(files) == 0:
        app['logger'].fatal("No files found in {}".format(path))
        sys.exit(1)
    else:
        app['logger'].fatal("Multiple files found in path {}".format(path))
        sys.exit(1)


def biobox_yaml_exists(app):
    """
    Was the biobox.yaml file created by the container?
    """
    return os.path.isfile(get_task_file_path(app, 'tmp/biobox.yaml'))


def get_output_biobox_file_contents(app):
    """
    Return the contents of the biobox.yaml file generated by the Docker container.
    """
    with open(get_task_file_path(app, 'tmp/biobox.yaml')) as f:
        return yaml.load(f.read())['arguments']


def get_biobox_yaml_value(app, yaml_path):
    """
    Given an xpath-type look up, returns the value in the biobox.yaml file
    """
    biobox_file = get_output_biobox_file_contents(app)
    return funcy.get_in(biobox_file, yaml_path + ['value'])

#########################################
#
# Misc file operations
#
#########################################

# http://stackoverflow.com/a/4213255/91144
def sha_digest(filename):
    """
    Returns the sha256sum for a given file path.
    """
    import hashlib
    sha = hashlib.sha256()
    with open(filename,'rb') as f:
        for chunk in iter(lambda: f.read(sha.block_size), b''):
            sha.update(chunk)
    return sha.hexdigest()


def copy_file_to_outputs(app, src_file, dst_dir):
    """
    Copies a Docker container generated file to the output directory. The name of
    the file will be the 10-character truncated sha256sum of the file contents.
    """
    import shutil
    src = get_task_file_path(app, src_file)
    dst = get_task_file_path(app, 'outputs/{}/{}'.format(dst_dir, sha_digest(src)[:10]))
    fu.mkdir_p(os.path.dirname(dst))
    shutil.copy(src, dst)


def create_runtime_metric_file(app, metrics):
    """
    Parses the raw cgroup data collected from the Docker container into a new file
    containing a JSON dictionary of key/value nucleotides metrics suitable for
    upload to the nuclotides API.
    """
    import gzip
    dst = get_task_file_path(app, 'outputs/container_runtime_metrics/metrics.json.gz')
    with gzip.open(dst, 'w') as f:
        f.write(json.dumps(metrics))


def copy_container_output_files(app, paths):
    """
    Given a dictionary of files that are expected to be generated by the Docker
    container, copies them to the corresponding destination subdirectory under
    ./outputs/. Skips files that do not exist.
    """
    for (dir_name, src_path) in paths.items():
        if os.path.isfile(get_task_file_path(app, src_path)):
            copy_file_to_outputs(app, src_path, dir_name)
            app['logger'].info("Copied generated {} file '{}'".format(dir_name, src_path))
        else:
            app['logger'].warn("Expected {} file not found '{}'".format(dir_name, src_path))
